{"primaryContentSections":[{"kind":"content","content":[{"anchor":"The-problem","level":2,"type":"heading","text":"The problem"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The ergonomics of Swift’s "},{"type":"codeVoice","code":"struct"},{"type":"text","text":"s are excellent. Picture this one:"}]},{"type":"codeListing","syntax":"swift","code":["struct Person {","\tlet name: String","\tlet age: Int","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You get one initializer, "},{"type":"codeVoice","code":"Person(name:age:)"},{"type":"text","text":" without extra work, and even more initializers if you turn the "},{"type":"codeVoice","code":"let"},{"type":"text","text":"s"},{"type":"text","text":" "},{"type":"text","text":"into "},{"type":"codeVoice","code":"vars"},{"type":"text","text":" and provide default values. Imagine"},{"type":"text","text":" "},{"type":"text","text":"this "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" instead:"}]},{"type":"codeListing","syntax":"swift","code":["struct Person {","\tvar name: String = \"\"","\tvar age: Int = 0","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, besides "},{"type":"codeVoice","code":"Person(name:age:)"},{"type":"text","text":", you’ll also get "},{"type":"codeVoice","code":"Person()"},{"type":"text","text":", "},{"type":"codeVoice","code":"Person(name:)"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Person(age:)"},{"type":"text","text":" without having to write any extra code. This automated synthesis shines when"},{"type":"text","text":" "},{"type":"text","text":"you want some stand-in instance."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Should you want to add another field with a default value to the struct, say "},{"type":"codeVoice","code":"phoneNumber"},{"type":"text","text":","}]},{"type":"codeListing","syntax":"swift","code":["struct Person {","\tvar name: String = \"\"","\tvar age: Int = 0","\tvar phoneNumber: String = \"\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"then the rest of your program (remember when we called apps “programs”?)"},{"type":"text","text":" "},{"type":"text","text":"will keep on working without modification. Good code"},{"type":"text","text":" "},{"type":"text","text":"is malleable — easy to adapt to new requirements."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sadly, all of this breaks when you want to consume a "},{"type":"codeVoice","code":"struct"},{"type":"text","text":" from one module"},{"type":"text","text":" "},{"type":"text","text":"into another. (This happens to me a lot since I’m a fan of The Composable Architecture,"},{"type":"text","text":" "},{"type":"text","text":"and I like splitting my app into isolated feature-based packages.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Under these circumstances, you need to declare a "},{"type":"codeVoice","code":"public"},{"type":"text","text":" initializer in the "},{"type":"codeVoice","code":"struct"},{"type":"text","text":" you want to use."}]},{"type":"codeListing","syntax":"swift","code":["struct Person {","\tinit(name: String = \"\", age: Int = 0) {","\t\tself.name = name","\t\tself.age = age","\t}","","\tvar name: String","\tvar age: Int","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Code is now double as long! Even worse, let’s say we add a phone number:"}]},{"type":"codeListing","syntax":"swift","code":["public struct Person {","\tpublic init(name: String = \"\", age: Int = 0, phoneNumber: String = \"\") {","\t\tself.name = name","\t\tself.age = age","\t\tself.phoneNumber = phoneNumber","\t}","","\tpublic var name: String","\tpublic var age: Int","\tpublic var phoneNumber: String","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order not to break existing clients of "},{"type":"codeVoice","code":"Person"},{"type":"text","text":", we had to modify"},{"type":"text","text":" "},{"type":"text","text":"three different lines, compared to the one-line change we did"},{"type":"text","text":" "},{"type":"text","text":"do above."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Ergonomics improve a lot if you use a parameter-less "},{"type":"codeVoice","code":"init"},{"type":"text","text":" and configure the instance"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"a posteriori"}]},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["public struct Person {","\tpublic init() {}","","\tpublic var name: String = \"\"","\tpublic var age: Int = 0","}","","var john = Person()","john.name = \"John\"","john.age = 41"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, adding a new field will have a more manageable ripple effect."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, I’d argue the code is weaker now. We’ve detached"},{"type":"text","text":" "},{"type":"text","text":"initialization from configuration, so it doesn’t reveal intention as clearly as"},{"type":"text","text":" "},{"type":"text","text":"before. Plus,"},{"type":"text","text":" "},{"type":"text","text":"it may be semantically incorrect: now "},{"type":"codeVoice","code":"john"},{"type":"text","text":" is forcefully a "},{"type":"codeVoice","code":"var"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"regardless of whether we want to mutate it afterward or not."}]},{"anchor":"The-solution","level":2,"type":"heading","text":"The solution"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Tap"},{"type":"text","text":" fixes this by providing you with a protocol, "},{"type":"codeVoice","code":"Tappable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"that allows you to do this:"}]},{"type":"codeListing","syntax":"swift","code":["public struct Person: Tappable {","\tpublic init() {}","","\tpublic var name: String = \"\"","\tpublic var age: Int = 0","}","","let john = Person().tap { john in","\tjohn.name = \"John\"","\tjohn.age = 41","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now you have structs that are easy to change across modules, and your code is as clear as if you were using your synthesized initializers."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that "},{"type":"codeVoice","code":"Tap"},{"type":"text","text":" also improves ergonomics in another way: whereas initializers require a specific argument order, configuration blocks don’t suffer from that"},{"type":"text","text":" "},{"type":"text","text":"constraint."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If your struct complies with "},{"type":"codeVoice","code":"DefaultConstructible"},{"type":"text","text":" (provided by us), you can be"},{"type":"text","text":" "},{"type":"text","text":"even more succinct by using "},{"type":"codeVoice","code":".tap"},{"type":"text","text":" as a static function. I find this particularly"},{"type":"text","text":" "},{"type":"text","text":"useful when deriving structs in The Composable Architecture:"}]},{"type":"codeListing","syntax":"swift","code":["public struct PersonState: Equatable, Tappable, DefaultConstructible {","\tpublic init() {}","","\tpublic var name: String = \"\"","\tpublic var age: Int = 0","}","","struct AppState: Equatable {","\tpublic var name: String = \"\"","\tpublic var age: Int = 0","","\tvar personState: PersonState {","\t\t.tap { state in","\t\t\tstate.name = name","\t\t\tstate.age = age","\t\t}","\t}","}"]}]}],"schemaVersion":{"major":0,"minor":2,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/tap"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Tap\/documentation\/Tap","interfaceLanguage":"swift"},"abstract":[{"type":"codeVoice","code":"Tap"},{"type":"text","text":" is a tiny library (11 LOC!) that lets you configure instances after"},{"type":"text","text":" "},{"type":"text","text":"their initialization without sacrificing your code’s semantics."},{"type":"text","text":" "},{"type":"text","text":"It works similarly to Ruby’s "},{"type":"codeVoice","code":"#tap"},{"type":"text","text":"."}],"kind":"symbol","metadata":{"roleHeading":"Framework","externalID":"Tap","title":"Tap","symbolKind":"module","role":"collection","modules":[{"name":"Tap"}]},"hierarchy":{"paths":[[]]},"topicSections":[{"title":"Protocols","identifiers":["doc:\/\/Tap\/documentation\/Tap\/DefaultConstructible","doc:\/\/Tap\/documentation\/Tap\/Tappable"]}],"references":{"doc://Tap/documentation/Tap":{"role":"collection","title":"Tap","abstract":[{"type":"codeVoice","code":"Tap"},{"type":"text","text":" is a tiny library (11 LOC!) that lets you configure instances after"},{"type":"text","text":" "},{"type":"text","text":"their initialization without sacrificing your code’s semantics."},{"type":"text","text":" "},{"type":"text","text":"It works similarly to Ruby’s "},{"type":"codeVoice","code":"#tap"},{"type":"text","text":"."}],"identifier":"doc:\/\/Tap\/documentation\/Tap","kind":"symbol","type":"topic","url":"\/documentation\/tap"},"doc://Tap/documentation/Tap/DefaultConstructible":{"role":"symbol","title":"DefaultConstructible","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DefaultConstructible"}],"abstract":[{"type":"text","text":"A type that you can initialize without any arguments."}],"identifier":"doc:\/\/Tap\/documentation\/Tap\/DefaultConstructible","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DefaultConstructible"}],"url":"\/documentation\/tap\/defaultconstructible"},"doc://Tap/documentation/Tap/Tappable":{"role":"symbol","title":"Tappable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Tappable"}],"abstract":[{"type":"text","text":"A type that you can build with a configuration block."}],"identifier":"doc:\/\/Tap\/documentation\/Tap\/Tappable","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Tappable"}],"url":"\/documentation\/tap\/tappable"}}}